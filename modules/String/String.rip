$
  #include "clib/stringbuf.h"

  static inline int64 strindex(char* s, int64 i)
  {
    int64 n = strlen(s);
    if (i > 0){
      if (i > n) goto bad_index;
      return i-1;
    }
    if (i == 0) goto bad_index;
    if (i < -n) goto bad_index;
    return i+n;
  bad_index:
    exc_raise("bad index %"PRId64" in string of length %"PRId64,
              i, n);
  }
$

class String
  $
    String s;
  $

  index(i)
    $
      return int64_to_val(@s.str[strindex(@s.str, val_to_int64(__i))]);
    $

  index_set(i, v)
    $
      @s.str[strindex(@s.str, val_to_int64(__i))] = (char) val_to_int64(__v);
    $

  to_string()
    return self

  strip()
    $
      char* s = @s.str;
      while (*s == ' ' or *s == '\t' or *s == '\n') s++;
      int64 n = strlen(s);
      char d[n + 1];
      strcpy(d, s);
      char* p = d + n - 1;
      while (*p == ' ' or *p == '\t' or *p == '\n'){
        *p = 0;
        p--;
      }
    $
    return $ string_to_val(d) $

  split(chars)
    arr = []
    word = nil
    $
      char* string = @s.str;
      char* chars = val_to_string(__chars);
      bool in_word = false;
      StringBuf sb;
      sbuf_init(&sb, "");
      while (*string != 0){
        bool whitespace = false;
        if (strchr(chars, *string))
          whitespace = true;
        if (in_word){
          if (whitespace){
    $
    word = $ string_to_val(sb.str) $
    arr.push(word)
    $
            in_word = false;
          } else {
            sbuf_catc(&sb, *string);
          }
        } else {
          if (whitespace){
            /* move on */
          } else {
            sbuf_clear(&sb);
            in_word = true;
            sbuf_catc(&sb, *string);
          }
        }
        string++;
      }
      if (in_word){
    $
    word = $ string_to_val(sb.str) $
    arr.push(word)
    $
      }
      sbuf_deinit(&sb);
    $
    return arr

  split_whitespace()
    return self.split(" \n\t")
